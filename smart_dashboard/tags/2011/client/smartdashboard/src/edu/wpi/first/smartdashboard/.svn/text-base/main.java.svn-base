package edu.wpi.first.smartdashboard;

import edu.wpi.first.smartdashboard.gui.DashboardPrefs;
import edu.wpi.first.smartdashboard.gui.MainWindow;
import edu.wpi.first.smartdashboard.net.UDPListener;
import edu.wpi.first.smartdashboard.video.VideoController;
import javax.swing.JOptionPane;
/**
 * Main SmartDashboard logic
 * @author pmalmsten
 */
public class main {
    private static final int PORT = 1165;
    private static final int UPDATE_NUM_OFFSET = 26;
    private static UDPListener m_listener;
    private static StateManager m_stateMan;
    private static LogToCSV csvLogger;

    public static void main(String[] args) {
        try {
            m_listener = new UDPListener(PORT, UPDATE_NUM_OFFSET);
        } catch (java.net.SocketException ex) {
            // need some errors here, particularly one if the address is already in
            // use, indicating that there is another instance of the dashboard running
            // somewhere on this system.
            JOptionPane.showMessageDialog(null,
                                          "The dashboard was unable to bind to "
                                          + "port " + PORT + ". Is an instance of "
                                          + "the dashboard already running?",
                                          "Unable to Bind to Port",
                                          JOptionPane.ERROR_MESSAGE);
            System.exit(1);
        }

        // Initialize the background network thread
        m_stateMan = new StateManager(m_listener);
        m_stateMan.start();

        // Initialize GUI
        MainWindow.init(m_stateMan);

        // Initialize video
        DashboardPrefs prefs = DashboardPrefs.getInstance();
        if(prefs.getShowCameraVideo()) {
            VideoController.showVideo();
            VideoController.startReceivingVideo(prefs.getCameraVideoTeamNumber());
        }
        prefs.addPreferenceChangeListener(VideoController.videoPreferencesChangeListener);

        // Initialize CSV
        registerAndInitLogger(new LogToCSV());
    }

    /*
     * This method prepares the program to accept state information un-serialized
     * from a file.
     */
    public static void prepareForSerializationLoad() {
        // Discard the current logger
        if(csvLogger != null) {
            csvLogger.stop();
            m_stateMan.unregisterForAnnouncements(csvLogger);
            DashboardPrefs.getInstance().removePreferenceChangeListener(csvLogger.getPreferenceChangeListener());
            csvLogger = null;
        }
    }

    /*
     * This method handles any required post-load initalization.
     */
    public static void finalizeSerializationLoad() {
        // If the loaded state file didn't contain any references to a logger
        // object (perhaps generated by an older version of the client), then
        // the logger reference was probably cleared during pre-load preparation
        // and not restored. If this is the case, a new logger is registered for use,
        // thereby upgrading the old information in-place. Subsequent saves will now
        // include references to the logger.
        if(csvLogger == null)
            registerAndInitLogger(new LogToCSV());
    }

    /*
     * Registers the given LogToCSV object for receiving new field notifications
     * and preferences changes. Also starts the logger if it is enabled in
     * DashboardPrefs.
     */
    public static void registerAndInitLogger(LogToCSV logger) {
        if(logger == null)
            return;

        DashboardPrefs prefs = DashboardPrefs.getInstance();
        
        m_stateMan.registerForAnnouncements(logger);
        prefs.addPreferenceChangeListener(logger.getPreferenceChangeListener());
        
        if(prefs.getLogToCSVEnabled()) {
            logger.start(prefs.getLogToCSVFilePath());
        }

        csvLogger = logger;
    }
}
